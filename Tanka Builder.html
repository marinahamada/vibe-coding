<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tanka Lab — Beauty Research (iOS)</title>
<style>
  :root{
    --bgA:hsl(220 70% 18%);
    --bgB:hsl(265 70% 16%);
    --bgC:hsl(30 75% 18%);
    --sat: 1;
    --blur: 22px;
    --angle: 135deg;

    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.68);
    --line: rgba(255,255,255,.14);
    --card: rgba(255,255,255,.08);
    --shadow: 0 22px 70px rgba(0,0,0,.55);
    --radius: 18px;

    --blue:#0a84ff; --purple:#bf5af2; --green:#30d158; --orange:#ff9f0a; --pink:#ff2d55;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:18px;
    color:var(--text);
    font-family: system-ui, -apple-system, "SF Pro Display","SF Pro Text","Segoe UI", Arial;
    background:
      radial-gradient(1000px 520px at 15% 10%, color-mix(in oklab, var(--bgA) 92%, black) 0%, transparent 60%),
      radial-gradient(1000px 520px at 85% 10%, color-mix(in oklab, var(--bgB) 92%, black) 0%, transparent 60%),
      radial-gradient(1000px 560px at 70% 95%, color-mix(in oklab, var(--bgC) 92%, black) 0%, transparent 62%),
      linear-gradient(180deg, #060712, #0b1224);
    overflow-x:hidden;
  }
  .bg{
    position:fixed; inset:-40px;
    background: linear-gradient(var(--angle), var(--bgA), var(--bgB), var(--bgC));
    filter: saturate(var(--sat));
    opacity:.50;
    z-index:-2;
    animation: drift 14s ease-in-out infinite alternate;
  }
  .bg::after{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(900px 700px at 30% 30%, rgba(255,255,255,.07), transparent 60%),
      radial-gradient(900px 700px at 70% 60%, rgba(255,255,255,.05), transparent 60%),
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
    mix-blend-mode: overlay;
    filter: blur(calc(var(--blur) * .55));
    opacity:.55;
  }
  @keyframes drift{
    0%{ transform: translate3d(-10px,-10px,0) scale(1.06); }
    100%{ transform: translate3d(10px,6px,0) scale(1.08); }
  }

  .wrap{max-width:1100px;margin:0 auto}
  header{
    display:flex;justify-content:space-between;align-items:flex-end;gap:12px;margin-bottom:14px
  }
  h1{margin:0;font-size:18px;letter-spacing:.2px}
  .sub{margin-top:6px;color:var(--muted);font-size:12px;line-height:1.4}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 12px;border-radius:999px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.07);
    backdrop-filter: blur(18px);
    font-size:12px;color:var(--muted);
    box-shadow: 0 12px 28px rgba(0,0,0,.35);
    white-space:nowrap;
  }
  .grid{display:grid;grid-template-columns: 1.35fr 0.65fr;gap:14px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }

  .card{
    background:var(--card);
    border:1px solid var(--line);
    border-radius: var(--radius);
    padding:14px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(18px);
  }
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .sep{height:1px;background:rgba(255,255,255,.10);margin:12px 0}
  .label{color:var(--muted);font-size:12px}
  input, button{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.20);
    background: rgba(255,255,255,.07);
    color: var(--text);
    padding:10px 12px;
    font-size:13px;
    outline:none;
    box-shadow: 0 1px 0 rgba(255,255,255,.10) inset, 0 1px 2px rgba(0,0,0,.35);
  }
  input{min-width: 240px}
  input.small{min-width: 200px}
  button{cursor:pointer;user-select:none;transition: transform .05s ease, filter .15s ease}
  button:hover{filter:brightness(1.06)}
  button:active{transform: translateY(1px); filter:brightness(.98)}

  .btn.primary{
    background: linear-gradient(180deg, rgba(10,132,255,.95), rgba(10,132,255,.62));
    border-color: rgba(10,132,255,.55);
    color:#fff;
    box-shadow: 0 1px 0 rgba(255,255,255,.15) inset, 0 18px 40px rgba(10,132,255,.22);
  }
  .btn.secondary{
    background: linear-gradient(180deg, rgba(191,90,242,.92), rgba(191,90,242,.58));
    border-color: rgba(191,90,242,.55);
    color:#fff;
    box-shadow: 0 1px 0 rgba(255,255,255,.15) inset, 0 18px 40px rgba(191,90,242,.18);
  }
  .btn.ghost{
    background: rgba(255,255,255,.06);
    border-color: rgba(255,255,255,.16);
  }

  .hint{color:var(--muted);font-size:12px;line-height:1.45}
  .hint strong{color:#fff}
  .warning{
    border:1px solid rgba(255,159,10,.35);
    background: rgba(255,159,10,.10);
    color:#ffe6c7;
    padding:10px 12px;
    border-radius: 14px;
    font-size:12px;
    line-height:1.45;
    display:none;
    margin-top:10px;
    white-space:pre-wrap;
  }

  /* Tiles pool */
  .pool{
    display:flex;flex-wrap:wrap;gap:10px;margin-top:12px
  }
  .tile{
    padding:10px 12px;border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.22);
    cursor:pointer;
    min-width: 110px;
    transition: transform .05s ease, filter .15s ease, opacity .15s ease;
  }
  .tile:hover{filter:brightness(1.05)}
  .tile:active{transform: translateY(1px)}
  .tile.used{opacity:.35; cursor:not-allowed}
  .tileTop{display:flex;justify-content:space-between;gap:10px;align-items:center;margin-bottom:6px}
  .tag{
    font-size:10.5px; padding:3px 8px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: var(--muted);
    white-space:nowrap;
  }
  .tag.theme{border-color: rgba(48,209,88,.35); color: rgba(209,255,229,.95);}
  .tag.neutral{border-color: rgba(10,132,255,.32); color: rgba(210,230,255,.95);}
  .word{font-size:16px; letter-spacing:.2px}
  .mora{font-family:var(--mono);font-size:11.5px;color:var(--muted)}

  /* Builder lines */
  .lines{display:flex;flex-direction:column;gap:10px;margin-top:14px}
  .lineCard{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.20);
    border-radius: 16px;
    padding:12px;
  }
  .lineCard.active{
    border-color: rgba(255,255,255,.32);
    background: rgba(255,255,255,.08);
  }
  .lineHead{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px}
  .badge{
    font-size:11px; padding:4px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: var(--muted);
    white-space:nowrap;
  }
  .badge.good{border-color: rgba(48,209,88,.35); color: rgba(220,255,238,.95);}
  .badge.bad{border-color: rgba(255,159,10,.35); color: rgba(255,231,200,.95);}
  .tokens{display:flex;flex-wrap:wrap;gap:8px}
  .token{
    padding:7px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    cursor:pointer;
    transition: filter .15s ease;
  }
  .token:hover{filter:brightness(1.07)}
  .token small{font-family:var(--mono);color:var(--muted);margin-left:6px}
  .lineFoot{display:flex;gap:10px;align-items:center;margin-top:10px}
  .mini{
    padding:8px 10px;
    font-size:12px;
    border-radius: 12px;
  }

  /* Research panel */
  .panelGrid{display:grid;grid-template-columns: 1fr 1fr;gap:12px}
  .kpiCard{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.18);
    border-radius: 16px;
    padding:12px;
  }
  .kpiTitle{font-size:12px;color:var(--muted);margin-bottom:8px}
  .kpiBig{font-size:18px}
  .bar{
    height:10px;border-radius:999px;
    background: rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .bar > div{
    height:100%;
    background: linear-gradient(90deg, rgba(10,132,255,.9), rgba(191,90,242,.8));
    width:0%;
  }
  .dots{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .dot{
    width:14px;height:14px;border-radius:999px;
    border:1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.08);
    position:relative;
  }
  .dot::after{
    content:"";
    position:absolute; inset:3px;
    border-radius:999px;
    background: rgba(255,255,255,.45);
    opacity:.0;
  }
  .dot.on::after{opacity:1}
  .dotLbl{font-family:var(--mono);font-size:11.5px;color:var(--muted)}
  .mono{font-family:var(--mono);font-size:12px;color:var(--muted)}
  .fullBox{
    white-space:pre-line;
    background: rgba(0,0,0,.20);
    border:1px solid rgba(255,255,255,.12);
    border-radius: 16px;
    padding:12px 14px;
    font-size:18px;
    line-height:2.0;
    min-height:140px;
  }
</style>
</head>
<body>
<div class="bg" aria-hidden="true"></div>

<div class="wrap">
  <header>
    <div>
      <h1>Tanka Lab — Beauty Research</h1>
      <div class="sub">Click Builder (no drag). Same 15 tiles per round (9 theme + 6 neutral, no duplicates). Build 5–7–5–7–7 and observe how structure changes the visual.</div>
    </div>
    <div class="pill" id="status">Ready</div>
  </header>

  <div class="grid">
    <!-- Left: builder -->
    <section class="card">
      <div class="row">
        <span class="label">Fixed word (surface)</span>
        <input id="fixedSurface" placeholder="e.g., 葡萄 / ぶどう / 車 / さくら" />

        <span class="label">Reading (hiragana)</span>
        <input id="fixedReading" class="small" placeholder="required for kanji: ぶどう / くるま" />

        <span class="label" id="autoHint" style="margin-left:auto">Kana OK</span>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="newRoundBtn" class="btn primary">New Round</button>
        <button id="resetBtn" class="btn ghost">Reset Layout</button>
        <button id="copyBtn" class="btn secondary">Copy</button>
      </div>

      <div class="hint" style="margin-top:10px">
        • Click a <strong>line</strong> to select it, then click a <strong>tile</strong> to place.<br/>
        • Click a placed token to remove (returns to pool).<br/>
        • Fixed word must be used at least once (you can place it via the Fixed tile).
      </div>

      <div class="warning" id="warningBox"></div>

      <div class="sep"></div>
      <div class="label">Tile pool (15 + Fixed)</div>
      <div class="pool" id="pool"></div>

      <div class="sep"></div>
      <div class="label">Builder</div>
      <div class="lines" id="lines"></div>

      <div class="sep"></div>
      <div class="label">Full tanka</div>
      <div class="fullBox" id="full"></div>
      <div class="mono" id="meter"></div>
    </section>

    <!-- Right: research panel -->
    <aside class="card">
      <div class="label">Research panel</div>
      <div class="hint" style="margin-top:8px">
        Visual reacts to structure (not “correctness”). Aim for <strong>symmetry</strong> or <strong>wobble</strong>—both are valid.
      </div>

      <div class="sep"></div>

      <div class="panelGrid">
        <div class="kpiCard">
          <div class="kpiTitle">Kanji density</div>
          <div style="display:flex;align-items:center;gap:12px">
            <svg id="ring" width="64" height="64" viewBox="0 0 64 64">
              <circle cx="32" cy="32" r="24" fill="none" stroke="rgba(255,255,255,.10)" stroke-width="8"/>
              <circle id="ringArc" cx="32" cy="32" r="24" fill="none" stroke="rgba(10,132,255,.85)" stroke-linecap="round" stroke-width="8"
                      stroke-dasharray="150.8" stroke-dashoffset="150.8" transform="rotate(-90 32 32)"/>
            </svg>
            <div>
              <div class="kpiBig" id="kanjiPct">0%</div>
              <div class="mono" id="kanjiNote">0 / 0</div>
            </div>
          </div>
        </div>

        <div class="kpiCard">
          <div class="kpiTitle">Abstract vs concrete (tokens)</div>
          <div class="bar"><div id="absBar"></div></div>
          <div class="mono" style="margin-top:8px" id="absNote">abstract 0 • concrete 0</div>
        </div>

        <div class="kpiCard">
          <div class="kpiTitle">Vowels (a i u e o)</div>
          <div class="dots">
            <span class="dotLbl">a</span><span class="dot" id="va"></span>
            <span class="dotLbl">i</span><span class="dot" id="vi"></span>
            <span class="dotLbl">u</span><span class="dot" id="vu"></span>
            <span class="dotLbl">e</span><span class="dot" id="ve"></span>
            <span class="dotLbl">o</span><span class="dot" id="vo"></span>
          </div>
          <div class="mono" style="margin-top:8px" id="vowelNote">a0 i0 u0 e0 o0</div>
        </div>

        <div class="kpiCard">
          <div class="kpiTitle">Balance polygon</div>
          <svg id="radar" width="160" height="120" viewBox="0 0 160 120">
            <polygon id="radarGrid" points="80,12 138,42 116,102 44,102 22,42"
                     fill="rgba(255,255,255,.03)" stroke="rgba(255,255,255,.10)"/>
            <polygon id="radarPoly" points="80,40 110,55 100,86 60,86 50,55"
                     fill="rgba(191,90,242,.18)" stroke="rgba(191,90,242,.70)" stroke-width="2"/>
          </svg>
          <div class="mono" id="radarNote">mora / kanji / concrete / vowel-even / hardness</div>
        </div>
      </div>

      <div class="sep"></div>
      <div class="label">Controls</div>
      <div class="hint" style="margin-top:8px">
        • <strong>New Round</strong>: new 15 tiles (same ratio).<br/>
        • <strong>Reset Layout</strong>: keep tiles, clear lines.<br/>
        • Click a line to set target; click tiles to place.
      </div>
    </aside>
  </div>
</div>

<script>
/* ===================== Basics ===================== */
const statusEl = document.getElementById("status");
const warnEl = document.getElementById("warningBox");
const fixedSurfaceEl = document.getElementById("fixedSurface");
const fixedReadingEl = document.getElementById("fixedReading");
const autoHintEl = document.getElementById("autoHint");
const poolEl = document.getElementById("pool");
const linesEl = document.getElementById("lines");
const fullEl = document.getElementById("full");
const meterEl = document.getElementById("meter");

const ringArc = document.getElementById("ringArc");
const kanjiPct = document.getElementById("kanjiPct");
const kanjiNote = document.getElementById("kanjiNote");
const absBar = document.getElementById("absBar");
const absNote = document.getElementById("absNote");
const va = document.getElementById("va");
const vi = document.getElementById("vi");
const vu = document.getElementById("vu");
const ve = document.getElementById("ve");
const vo = document.getElementById("vo");
const vowelNote = document.getElementById("vowelNote");
const radarPoly = document.getElementById("radarPoly");

function setStatus(t){ statusEl.textContent = t; }
function showWarn(msg){ warnEl.style.display="block"; warnEl.textContent = msg; }
function clearWarn(){ warnEl.style.display="none"; warnEl.textContent=""; }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

/* ===================== Mora utils ===================== */
const SMALL = new Set("ゃゅょぁぃぅぇぉゎャュョァィゥェォヮ".split(""));
function toHira(str){
  return (str||"").replace(/[\u30a1-\u30f6]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0x60));
}
function isKanaOnly(s){
  const h = toHira((s||"").trim());
  return !!h && /^[ぁ-ゖー]+$/.test(h);
}
function countMora(reading){
  const s = toHira((reading||"").trim());
  if(!s) return 0;
  let n = 0;
  for(const ch of s){
    if(ch === "ー"){ n++; continue; }
    if(SMALL.has(ch)) continue;
    if(ch.match(/[ぁ-ゖ]/)) n++;
  }
  return n;
}

/* ===================== Vowel + hardness ===================== */
// very small heuristic: map kana to vowel by last vowel in syllable
const VOWELS = ["a","i","u","e","o"];
function kanaVowel(ch){
  const c = ch;
  // small kana handled by skipping in mora count, but for vowel we ignore them too
  if(SMALL.has(c)) return null;
  if(c === "ー") return null;
  // map by ranges (approx)
  const a = "あかさたなはまやらわがざだばぱぁゃ";
  const i = "いきしちにひみりぎじぢびぴぃ";
  const u = "うくすつぬふむゆるぐずづぶぷぅゅ";
  const e = "えけせてねへめれげぜでべぺぇ";
  const o = "おこそとのほもよろをごぞどぼぽぉょを";
  if(a.includes(c)) return "a";
  if(i.includes(c)) return "i";
  if(u.includes(c)) return "u";
  if(e.includes(c)) return "e";
  if(o.includes(c)) return "o";
  return null;
}
function readingVowels(reading){
  const s = toHira((reading||"").trim());
  const out = [];
  for(const ch of s){
    const v = kanaVowel(ch);
    if(v) out.push(v);
  }
  return out;
}
function readingHardness(reading){
  const s = toHira((reading||"").trim());
  // rough consonant-class heuristic
  // hard: k,s,t,p,g,z,d,b (sharp); soft: m,n,r,y,w,h (airy); other neutral
  let score = 0, cnt = 0;
  for(const ch of s){
    if(SMALL.has(ch) || ch==="ー") continue;
    if(!ch.match(/[ぁ-ゖ]/)) continue;
    cnt++;
    const hard = "かきくけこさしすせそたちつてとぱぴぷぺぽがぎぐげござじずぜぞだぢづでどばびぶべぼ";
    const soft = "まみむめもなにぬねのらりるれろやゆよわをはひふへほ";
    if(hard.includes(ch)) score += 1.0;
    else if(soft.includes(ch)) score += 0.35;
    else score += 0.55;
  }
  return cnt ? (score/cnt) : 0.5; // 0..1-ish
}

/* ===================== RNG ===================== */
function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=(h<<13)|(h>>>19);}return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return (h^=(h>>>16))>>>0;};}
function sfc32(a,b,c,d){return function(){a>>>=0;b>>>=0;c>>>=0;d>>>=0;let t=(a+b)|0;a=b^(b>>>9);b=(c+(c<<3))|0;c=(c<<21)|(c>>>11);d=(d+1)|0;t=(t+d)|0;c=(c+t)|0;return (t>>>0)/4294967296;};}
function makeRng(seed){const s=xmur3(seed);return sfc32(s(),s(),s(),s());}
function randi(rng,min,max){return Math.floor(rng()*(max-min+1))+min;}
function pick(rng, arr){return arr[randi(rng,0,arr.length-1)];}

/* ===================== Vocab packs ===================== */
function T(surface, reading, kind, isAbstract){
  return {
    id: crypto?.randomUUID?.() || (Math.random().toString(16).slice(2)),
    surface,
    reading: toHira(reading),
    kind, // "theme" | "neutral" | "fixed"
    isAbstract: !!isAbstract,
    mora: countMora(reading),
    hardness: readingHardness(reading),
    vowels: readingVowels(reading),
  };
}

// Memory × Water (theme)
const THEME = [
  // water/material (concrete-ish)
  T("水","みず","theme",false), T("水面","みなも","theme",false), T("湖面","こめん","theme",false),
  T("水脈","すいみゃく","theme",false), T("波紋","はもん","theme",false), T("気泡","きほう","theme",false),
  T("水滴","すいてき","theme",false), T("結露","けつろ","theme",false), T("湿度","しつど","theme",false),
  T("霧","きり","theme",false), T("潮","しお","theme",false), T("潮風","しおかぜ","theme",false),
  T("井戸","いど","theme",false), T("水路","すいろ","theme",false), T("透明","とうめい","theme",false),
  T("反射","はんしゃ","theme",false), T("揺らぎ","ゆらぎ","theme",false), T("薄氷","うすごおり","theme",false),
  T("水底","みなそこ","theme",false), T("水音","みずおと","theme",false),

  // memory/time (more abstract)
  T("記憶","きおく","theme",true), T("残像","ざんぞう","theme",true), T("断片","だんぺん","theme",true),
  T("記録","きろく","theme",true), T("余白","よはく","theme",true), T("白紙","はくし","theme",true),
  T("気配","けはい","theme",true), T("静止","せいし","theme",true), T("未明","みめい","theme",true),
  T("既視","きし","theme",true), T("昨日","きのう","theme",true), T("今夜","こんや","theme",true),
  T("背景","はいけい","theme",true), T("距離","きょり","theme",true), T("輪郭","りんかく","theme",true),
  T("境界","きょうかい","theme",true), T("深度","しんど","theme",true), T("反復","はんぷく","theme",true),
  T("沈黙","ちんもく","theme",true), T("呼応","こおう","theme",true),
];

// Neutral core (universal)
const NEUTRAL = [
  // space/time/people (mixed)
  T("朝","あさ","neutral",false), T("夜","よる","neutral",false), T("空","そら","neutral",false),
  T("影","かげ","neutral",false), T("窓","まど","neutral",false), T("部屋","へや","neutral",false),
  T("道","みち","neutral",false), T("駅","えき","neutral",false), T("手","て","neutral",false),
  T("目","め","neutral",false), T("声","こえ","neutral",false),
  T("あなた","あなた","neutral",true), T("わたし","わたし","neutral",true),
  T("ここ","ここ","neutral",true), T("そこ","そこ","neutral",true),
  T("今日","きょう","neutral",true), T("明日","あした","neutral",true),
  T("風","かぜ","neutral",false), T("雨","あめ","neutral",false), T("光","ひかり","neutral",false),
];

/* ===================== State ===================== */
const TARGET = [5,7,5,7,7];

const state = {
  seed: "",
  roundTiles: [],      // 15 tiles (theme+neutral), unique
  used: new Set(),     // tile ids used in lines
  lines: [[],[],[],[],[]], // arrays of tile ids (including fixed id)
  activeLine: 0,
  fixedToken: null,    // tile object kind "fixed"
};

function getFixedToken(){
  const surface = (fixedSurfaceEl.value||"").trim();
  const readingInput = (fixedReadingEl.value||"").trim();

  if(!surface) throw new Error("Please enter a fixed word.");

  if(isKanaOnly(surface)){
    const r = toHira(surface);
    if(countMora(r) <= 0) throw new Error("Could not read fixed word. Use hiragana.");
    return T(surface, r, "fixed", true);
  }

  if(!readingInput) throw new Error("Kanji detected. Please fill Reading in hiragana (e.g., 車 → くるま).");
  const r = toHira(readingInput);
  if(!isKanaOnly(r) || countMora(r) <= 0) throw new Error("Reading must be kana (recommended: hiragana).");
  return T(surface, r, "fixed", true);
}

function refreshHint(){
  const s = (fixedSurfaceEl.value||"").trim();
  if(!s){ autoHintEl.textContent = "Kana OK"; return; }
  autoHintEl.textContent = isKanaOnly(s) ? "Kana OK" : "Kanji detected → reading required";
}
fixedSurfaceEl.addEventListener("input", refreshHint);
refreshHint();

/* ===================== Round generation ===================== */
function uniqueSample(rng, arr, n){
  const pool = arr.slice();
  const out = [];
  while(out.length < n && pool.length){
    const idx = randi(rng, 0, pool.length-1);
    out.push(pool.splice(idx,1)[0]);
  }
  return out;
}

function newRound(){
  clearWarn();
  const fixed = getFixedToken();
  state.fixedToken = fixed;
  state.used = new Set();
  state.lines = [[],[],[],[],[]];
  state.activeLine = 0;

  state.seed = "round|" + fixed.reading + "|" + Date.now().toString(36) + "|" + Math.random().toString(36).slice(2,8);
  const rng = makeRng(state.seed);

  const theme9 = uniqueSample(rng, THEME, 9);
  const neutral6 = uniqueSample(rng, NEUTRAL, 6);

  // ensure no accidental duplicates by surface (rare but safe)
  const seenSurf = new Set();
  const tiles = [];
  for(const t of [...theme9, ...neutral6]){
    if(seenSurf.has(t.surface)) continue;
    seenSurf.add(t.surface);
    tiles.push(t);
  }
  // if duplicates removed, top-up from same pools
  while(tiles.length < 15){
    const source = (tiles.filter(x=>x.kind==="theme").length < 9) ? THEME : NEUTRAL;
    const cand = pick(rng, source);
    if(seenSurf.has(cand.surface)) continue;
    seenSurf.add(cand.surface);
    tiles.push(cand);
  }

  state.roundTiles = tiles;

  // Auto-place Fixed once? (No — let you decide. But we provide Fixed tile in pool.)
  setStatus("New round ✓");
  renderAll();
}

/* ===================== Builder logic ===================== */
function allTilesWithFixed(){
  // fixed tile appears as a pseudo tile in pool, usable once
  const fixed = state.fixedToken;
  return fixed ? [fixed, ...state.roundTiles] : [...state.roundTiles];
}
function findTileById(id){
  for(const t of allTilesWithFixed()){
    if(t.id === id) return t;
  }
  return null;
}
function lineMora(i){
  return state.lines[i].reduce((sum, id)=> sum + (findTileById(id)?.mora || 0), 0);
}
function canPlace(lineIdx, tile){
  if(!tile) return false;
  if(state.used.has(tile.id)) return false;
  const m = lineMora(lineIdx);
  return (m + tile.mora) <= TARGET[lineIdx];
}
function placeTile(lineIdx, tile){
  if(!tile) return;
  if(!canPlace(lineIdx, tile)){
    flashLine(lineIdx);
    setStatus("Doesn't fit");
    return;
  }
  state.lines[lineIdx].push(tile.id);
  state.used.add(tile.id);
  setStatus(`Placed on line ${lineIdx+1}`);
  renderAll();
}
function removeTile(tileId){
  // remove from any line
  for(let i=0;i<5;i++){
    const idx = state.lines[i].indexOf(tileId);
    if(idx !== -1){
      state.lines[i].splice(idx,1);
      state.used.delete(tileId);
      setStatus("Removed");
      renderAll();
      return;
    }
  }
}
function clearLine(i){
  for(const id of state.lines[i]){
    state.used.delete(id);
  }
  state.lines[i] = [];
  setStatus(`Cleared line ${i+1}`);
  renderAll();
}
function resetLayout(){
  clearWarn();
  state.used = new Set();
  state.lines = [[],[],[],[],[]];
  state.activeLine = 0;
  setStatus("Reset ✓");
  renderAll();
}

function flashLine(i){
  const el = document.querySelector(`[data-line="${i}"]`);
  if(!el) return;
  el.animate(
    [{filter:"brightness(1.0)"},{filter:"brightness(1.25)"},{filter:"brightness(1.0)"}],
    {duration:240}
  );
}

/* ===================== Rendering ===================== */
function renderPool(){
  const tiles = allTilesWithFixed();
  poolEl.innerHTML = "";
  for(const t of tiles){
    const div = document.createElement("div");
    div.className = "tile" + (state.used.has(t.id) ? " used" : "");
    div.dataset.id = t.id;
    const tagTxt = (t.kind==="fixed") ? "fixed" : (t.kind==="theme" ? "theme" : "neutral");
    const tagCls = (t.kind==="theme") ? "tag theme" : (t.kind==="neutral") ? "tag neutral" : "tag";
    div.innerHTML = `
      <div class="tileTop">
        <span class="${tagCls}">${tagTxt}</span>
        <span class="mora">${t.mora}</span>
      </div>
      <div class="word">${t.surface}</div>
      <div class="mora">${t.reading}</div>
    `;
    div.addEventListener("click", ()=>{
      if(state.used.has(t.id)) return;
      placeTile(state.activeLine, t);
    });
    poolEl.appendChild(div);
  }
}

function renderLines(){
  linesEl.innerHTML = "";
  for(let i=0;i<5;i++){
    const card = document.createElement("div");
    card.className = "lineCard" + (i===state.activeLine ? " active" : "");
    card.dataset.line = i;

    const m = lineMora(i);
    const ok = (m === TARGET[i]);
    const badge = ok ? `<span class="badge good">${m}/${TARGET[i]} ✓</span>`
                     : `<span class="badge ${m>TARGET[i]?'bad':''}">${m}/${TARGET[i]}</span>`;

    const tokens = state.lines[i].map(id=>{
      const t = findTileById(id);
      return `<span class="token" data-token="${id}">${t?.surface || "?"}<small>${t?.mora ?? ""}</small></span>`;
    }).join("");

    card.innerHTML = `
      <div class="lineHead">
        <div class="label">Line ${i+1} • target ${TARGET[i]}</div>
        ${badge}
      </div>
      <div class="tokens">${tokens || `<span class="label">Click tiles to add…</span>`}</div>
      <div class="lineFoot">
        <button class="mini btn ghost" data-act="select">Select</button>
        <button class="mini btn ghost" data-act="clear">Clear</button>
      </div>
    `;

    card.querySelector(`[data-act="select"]`).addEventListener("click", ()=>{
      state.activeLine = i;
      setStatus(`Selected line ${i+1}`);
      renderAll();
    });
    card.querySelector(`[data-act="clear"]`).addEventListener("click", ()=> clearLine(i));

    card.addEventListener("click", (e)=>{
      const tok = e.target.closest(".token");
      if(tok){
        const id = tok.dataset.token;
        removeTile(id);
      }
    });

    // clicking the card itself selects (nice on mobile)
    card.addEventListener("dblclick", ()=>{
      state.activeLine = i;
      setStatus(`Selected line ${i+1}`);
      renderAll();
    });

    linesEl.appendChild(card);
  }
}

function renderFull(){
  const linesTxt = state.lines.map((arr, i)=>{
    const text = arr.map(id=> findTileById(id)?.surface || "").join("");
    return text;
  });

  const linesRead = state.lines.map((arr, i)=>{
    const r = arr.map(id=> findTileById(id)?.reading || "").join("");
    return r;
  });

  fullEl.textContent = linesTxt.join("\n");

  const meters = linesRead.map(r=> countMora(r)).join(" / ");
  meterEl.textContent = `meter: ${meters}  (target: 5 / 7 / 5 / 7 / 7)`;

  return { linesTxt, linesRead };
}

/* ===================== Metrics + visuals ===================== */
function countKanji(str){
  // CJK Unified Ideographs
  const m = (str||"").match(/[\u4E00-\u9FFF]/g);
  return m ? m.length : 0;
}
function totalChars(str){
  return (str||"").replace(/\s/g,"").length;
}

function computeMetrics(linesTxt, linesRead){
  const joinedTxt = linesTxt.join("");
  const joinedRead = linesRead.join("");

  const k = countKanji(joinedTxt);
  const tot = totalChars(joinedTxt);
  const kanjiRatio = tot ? (k / tot) : 0;

  let abs = 0, conc = 0, tokenCount = 0;
  let hardnessSum = 0;

  const vowelCounts = {a:0,i:0,u:0,e:0,o:0};
  for(const arr of state.lines){
    for(const id of arr){
      const t = findTileById(id);
      if(!t) continue;
      tokenCount++;
      if(t.isAbstract) abs++; else conc++;
      hardnessSum += (t.hardness ?? 0.5);
      for(const v of (t.vowels||[])) vowelCounts[v] = (vowelCounts[v]||0)+1;
    }
  }

  const hardAvg = tokenCount ? (hardnessSum / tokenCount) : 0.5;

  // vowel evenness: 1 - normalized deviation
  const vTotal = VOWELS.reduce((s,v)=> s + vowelCounts[v], 0);
  let vEven = 0.5;
  if(vTotal){
    const p = VOWELS.map(v=> vowelCounts[v]/vTotal);
    const ideal = 1/5;
    const dev = p.reduce((s,x)=> s + Math.abs(x-ideal), 0); // 0..?
    vEven = clamp01(1 - dev*0.9);
  }

  // mora balance across lines (variance)
  const lineM = linesRead.map(r=> countMora(r));
  const mean = lineM.reduce((s,x)=>s+x,0)/5;
  const varr = lineM.reduce((s,x)=> s + (x-mean)*(x-mean), 0)/5;
  const moraBalance = clamp01(1 - (varr/6)); // heuristic

  const concreteRatio = tokenCount ? conc/tokenCount : 0;
  const abstractRatio = tokenCount ? abs/tokenCount : 0;

  return { kanjiRatio, k, tot, abs, conc, tokenCount, vowelCounts, vEven, hardAvg, moraBalance, abstractRatio, concreteRatio };
}

function setRing(pct){
  const C = 2*Math.PI*24; // ~150.8
  const off = C * (1 - pct);
  ringArc.setAttribute("stroke-dasharray", String(C));
  ringArc.setAttribute("stroke-dashoffset", String(off));
}

function setRadar(vals){
  // 5 axes (top, top-right, bottom-right, bottom-left, top-left) => 5 points
  // vals: [mora, kanji, concrete, vowelEven, hardnessSoft]
  const cx=80, cy=60;
  const R=44;
  const angles = [-90, -18, 54, 126, 198].map(a=> a*Math.PI/180);
  const pts = vals.map((v, i)=>{
    const rr = R * clamp01(v);
    const x = cx + rr * Math.cos(angles[i]);
    const y = cy + rr * Math.sin(angles[i]);
    return `${x.toFixed(1)},${y.toFixed(1)}`;
  }).join(" ");
  radarPoly.setAttribute("points", pts);
}

function applyBackground(m){
  // hue from vowels: a warm(28), i cool(210), u deep(235), e neutral(190), o purple(275)
  const hueMap = {a:28,i:210,u:235,e:190,o:275};
  const v = m.vowelCounts;
  const total = VOWELS.reduce((s,k)=>s+(v[k]||0),0) || 1;
  let hue = 220;
  let weight = 0;
  for(const k of VOWELS){
    const w = (v[k]||0)/total;
    hue += w * (hueMap[k]-220);
    weight += w;
  }
  // saturation rises with kanji; blur rises with abstract
  const sat = 0.9 + m.kanjiRatio * 0.9;
  const blur = 18 + m.abstractRatio * 22;

  // wobble angle: more imbalance => more tilt
  const wobble = 1 - m.moraBalance;
  const angle = 120 + wobble * 80;

  // choose three hues around the base; slightly shift by hardness
  const hard = m.hardAvg; // 0..1
  const hA = (hue + 18 + hard*12) % 360;
  const hB = (hue + 260 - hard*20 + 360) % 360;
  const hC = (hue + 90 + (1-hard)*16) % 360;

  // lightness: more concrete => slightly brighter; more abstract => darker
  const L = 16 + m.concreteRatio*6 - m.abstractRatio*3;

  document.documentElement.style.setProperty("--bgA", `hsl(${hA} 74% ${L}%)`);
  document.documentElement.style.setProperty("--bgB", `hsl(${hB} 70% ${Math.max(12,L-2)}%)`);
  document.documentElement.style.setProperty("--bgC", `hsl(${hC} 76% ${Math.min(22,L+2)}%)`);
  document.documentElement.style.setProperty("--sat", sat.toFixed(2));
  document.documentElement.style.setProperty("--blur", `${blur.toFixed(1)}px`);
  document.documentElement.style.setProperty("--angle", `${angle.toFixed(0)}deg`);
}

function renderPanel(m){
  // ring
  setRing(m.kanjiRatio);
  kanjiPct.textContent = `${Math.round(m.kanjiRatio*100)}%`;
  kanjiNote.textContent = `${m.k} / ${m.tot || 0}`;

  // abstract bar (left = abstract, right = concrete)
  const absPct = m.tokenCount ? (m.abs / m.tokenCount) : 0;
  absBar.style.width = `${Math.round(absPct*100)}%`;
  absNote.textContent = `abstract ${m.abs} • concrete ${m.conc}`;

  // vowel dots (on if dominant-ish)
  const total = VOWELS.reduce((s,k)=>s+(m.vowelCounts[k]||0),0) || 1;
  const dom = Math.max(...VOWELS.map(k=> (m.vowelCounts[k]||0)/total));
  const th = Math.max(0.18, dom*0.75); // relative threshold
  function setDot(el, k){
    const p = (m.vowelCounts[k]||0)/total;
    el.classList.toggle("on", p >= th && m.tokenCount>0);
  }
  setDot(va,"a"); setDot(vi,"i"); setDot(vu,"u"); setDot(ve,"e"); setDot(vo,"o");
  vowelNote.textContent = `a${m.vowelCounts.a||0} i${m.vowelCounts.i||0} u${m.vowelCounts.u||0} e${m.vowelCounts.e||0} o${m.vowelCounts.o||0}`;

  // radar: [moraBalance, kanjiRatio, concreteRatio, vowelEven, softness]
  const softness = clamp01(1 - (m.hardAvg - 0.35) / 0.75); // invert hardness → softness-ish
  setRadar([m.moraBalance, m.kanjiRatio, m.concreteRatio, m.vEven, softness]);
}

function validateFixedUsed(){
  const f = state.fixedToken;
  if(!f) return false;
  return state.used.has(f.id);
}

/* ===================== Render all ===================== */
function renderAll(){
  renderPool();
  renderLines();
  const {linesTxt, linesRead} = renderFull();
  const m = computeMetrics(linesTxt, linesRead);
  applyBackground(m);
  renderPanel(m);

  // gentle warnings
  const missingFixed = state.fixedToken && !validateFixedUsed();
  const anyOver = [0,1,2,3,4].some(i=> lineMora(i) > TARGET[i]);
  const anyIncomplete = [0,1,2,3,4].some(i=> lineMora(i) !== TARGET[i]);

  if(anyOver){
    showWarn("One or more lines exceed the mora target. Remove a token.");
  }else if(missingFixed){
    showWarn("Fixed word is not used yet. Place the Fixed tile at least once.");
  }else{
    clearWarn();
  }

  if(!anyOver && !missingFixed && !anyIncomplete){
    setStatus("Complete ✓");
  }
}

/* ===================== Buttons ===================== */
document.getElementById("newRoundBtn").addEventListener("click", ()=>{
  try{ newRound(); }
  catch(e){ setStatus("Error"); showWarn(e.message || String(e)); }
});

document.getElementById("resetBtn").addEventListener("click", ()=>{
  resetLayout();
});

document.getElementById("copyBtn").addEventListener("click", async ()=>{
  const text = fullEl.textContent || "";
  if(!text.trim()){ setStatus("Nothing to copy"); return; }
  try{
    await navigator.clipboard.writeText(text);
    setStatus("Copied ✓");
  }catch{
    setStatus("Copy failed");
    showWarn("Copy failed due to browser permission. You can select & copy manually.");
  }
});

/* ===================== Boot ===================== */
(function boot(){
  fixedSurfaceEl.value = "葡萄";
  fixedReadingEl.value = "ぶどう";
  try{
    newRound();
    setStatus("Ready ✓");
  }catch(e){
    setStatus("Ready");
    showWarn(e.message || String(e));
  }
})();
</script>
</body>
</html>