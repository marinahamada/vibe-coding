<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tanka Lab — Beauty Research (iOS)</title>
<style>
  :root{
    --bgA:hsl(220 70% 18%);
    --bgB:hsl(265 70% 16%);
    --bgC:hsl(30 75% 18%);
    --sat: 1;
    --blur: 22px;
    --angle: 135deg;

    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.68);
    --line: rgba(255,255,255,.14);
    --card: rgba(255,255,255,.08);
    --shadow: 0 22px 70px rgba(0,0,0,.55);
    --radius: 18px;

    --blue:#0a84ff; --purple:#bf5af2; --green:#30d158; --orange:#ff9f0a; --pink:#ff2d55; --red:#ff453a;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:18px;
    color:var(--text);
    font-family: system-ui, -apple-system, "SF Pro Display","SF Pro Text","Segoe UI", Arial;
    background:
      radial-gradient(1000px 520px at 15% 10%, color-mix(in oklab, var(--bgA) 92%, black) 0%, transparent 60%),
      radial-gradient(1000px 520px at 85% 10%, color-mix(in oklab, var(--bgB) 92%, black) 0%, transparent 60%),
      radial-gradient(1000px 560px at 70% 95%, color-mix(in oklab, var(--bgC) 92%, black) 0%, transparent 62%),
      linear-gradient(180deg, #060712, #0b1224);
    overflow-x:hidden;
  }
  .bg{
    position:fixed; inset:-40px;
    background: linear-gradient(var(--angle), var(--bgA), var(--bgB), var(--bgC));
    filter: saturate(var(--sat));
    opacity:.50;
    z-index:-2;
    animation: drift 14s ease-in-out infinite alternate;
  }
  .bg::after{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(900px 700px at 30% 30%, rgba(255,255,255,.07), transparent 60%),
      radial-gradient(900px 700px at 70% 60%, rgba(255,255,255,.05), transparent 60%),
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
    mix-blend-mode: overlay;
    filter: blur(calc(var(--blur) * .55));
    opacity:.55;
  }
  @keyframes drift{
    0%{ transform: translate3d(-10px,-10px,0) scale(1.06); }
    100%{ transform: translate3d(10px,6px,0) scale(1.08); }
  }

  .wrap{max-width:1100px;margin:0 auto}
  header{
    display:flex;justify-content:space-between;align-items:flex-end;gap:12px;margin-bottom:14px
  }
  h1{margin:0;font-size:18px;letter-spacing:.2px}
  .sub{margin-top:6px;color:var(--muted);font-size:12px;line-height:1.4}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 12px;border-radius:999px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.07);
    backdrop-filter: blur(18px);
    font-size:12px;color:var(--muted);
    box-shadow: 0 12px 28px rgba(0,0,0,.35);
    white-space:nowrap;
  }
  .grid{display:grid;grid-template-columns: 1.35fr 0.65fr;gap:14px}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }

  .card{
    background:var(--card);
    border:1px solid var(--line);
    border-radius: var(--radius);
    padding:14px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(18px);
  }
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .sep{height:1px;background:rgba(255,255,255,.10);margin:12px 0}
  .label{color:var(--muted);font-size:12px}
  input, button{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.20);
    background: rgba(255,255,255,.07);
    color: var(--text);
    padding:10px 12px;
    font-size:13px;
    outline:none;
    box-shadow: 0 1px 0 rgba(255,255,255,.10) inset, 0 1px 2px rgba(0,0,0,.35);
  }
  input{min-width: 240px}
  input.small{min-width: 200px}
  button{cursor:pointer;user-select:none;transition: transform .05s ease, filter .15s ease}
  button:hover{filter:brightness(1.06)}
  button:active{transform: translateY(1px); filter:brightness(.98)}

  .btn.primary{
    background: linear-gradient(180deg, rgba(10,132,255,.95), rgba(10,132,255,.62));
    border-color: rgba(10,132,255,.55);
    color:#fff;
    box-shadow: 0 1px 0 rgba(255,255,255,.15) inset, 0 18px 40px rgba(10,132,255,.22);
  }
  .btn.secondary{
    background: linear-gradient(180deg, rgba(191,90,242,.92), rgba(191,90,242,.58));
    border-color: rgba(191,90,242,.55);
    color:#fff;
    box-shadow: 0 1px 0 rgba(255,255,255,.15) inset, 0 18px 40px rgba(191,90,242,.18);
  }
  .btn.ghost{
    background: rgba(255,255,255,.06);
    border-color: rgba(255,255,255,.16);
  }

  .hint{color:var(--muted);font-size:12px;line-height:1.45}
  .hint strong{color:#fff}
  .warning{
    border:1px solid rgba(255,159,10,.35);
    background: rgba(255,159,10,.10);
    color:#ffe6c7;
    padding:10px 12px;
    border-radius: 14px;
    font-size:12px;
    line-height:1.45;
    display:none;
    margin-top:10px;
    white-space:pre-wrap;
  }

  /* Tiles pool */
  .pool{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
  .tile{
    padding:10px 12px;border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.22);
    cursor:pointer;
    min-width: 110px;
    transition: transform .05s ease, filter .15s ease, opacity .15s ease;
  }
  .tile:hover{filter:brightness(1.05)}
  .tile:active{transform: translateY(1px)}
  .tile.used{opacity:.35; cursor:not-allowed}
  .tileTop{display:flex;justify-content:space-between;gap:10px;align-items:center;margin-bottom:6px}
  .tag{
    font-size:10.5px; padding:3px 8px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: var(--muted);
    white-space:nowrap;
  }
  .tag.theme{border-color: rgba(48,209,88,.35); color: rgba(209,255,229,.95);}
  .tag.neutral{border-color: rgba(10,132,255,.32); color: rgba(210,230,255,.95);}
  .tag.particle{border-color: rgba(255,159,10,.40); color: rgba(255,236,210,.95);}
  .tag.action{border-color: rgba(255,45,85,.40); color: rgba(255,219,231,.95);}
  .word{font-size:16px; letter-spacing:.2px}
  .mora{font-family:var(--mono);font-size:11.5px;color:var(--muted)}

  /* Builder lines */
  .lines{display:flex;flex-direction:column;gap:10px;margin-top:14px}
  .lineCard{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.20);
    border-radius: 16px;
    padding:12px;
  }
  .lineCard.active{
    border-color: rgba(255,255,255,.32);
    background: rgba(255,255,255,.08);
  }
  .lineHead{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px}
  .badge{
    font-size:11px; padding:4px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: var(--muted);
    white-space:nowrap;
  }
  .badge.good{border-color: rgba(48,209,88,.35); color: rgba(220,255,238,.95);}
  .badge.bad{border-color: rgba(255,159,10,.35); color: rgba(255,231,200,.95);}
  .tokens{display:flex;flex-wrap:wrap;gap:8px}
  .token{
    padding:7px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    cursor:pointer;
    transition: filter .15s ease;
  }
  .token:hover{filter:brightness(1.07)}
  .token small{font-family:var(--mono);color:var(--muted);margin-left:6px}
  .lineFoot{display:flex;gap:10px;align-items:center;margin-top:10px}
  .mini{padding:8px 10px;font-size:12px;border-radius: 12px}

  /* Research panel */
  .panelGrid{display:grid;grid-template-columns: 1fr 1fr;gap:12px}
  .kpiCard{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.18);
    border-radius: 16px;
    padding:12px;
  }
  .kpiTitle{font-size:12px;color:var(--muted);margin-bottom:8px}
  .kpiBig{font-size:18px}
  .bar{
    height:10px;border-radius:999px;
    background: rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .bar > div{
    height:100%;
    background: linear-gradient(90deg, rgba(10,132,255,.9), rgba(191,90,242,.8));
    width:0%;
  }
  .dots{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .dot{
    width:14px;height:14px;border-radius:999px;
    border:1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.08);
    position:relative;
  }
  .dot::after{
    content:"";
    position:absolute; inset:3px;
    border-radius:999px;
    background: rgba(255,255,255,.45);
    opacity:.0;
  }
  .dot.on::after{opacity:1}
  .dotLbl{font-family:var(--mono);font-size:11.5px;color:var(--muted)}
  .mono{font-family:var(--mono);font-size:12px;color:var(--muted)}
  .fullBox{
    white-space:pre-line;
    background: rgba(0,0,0,.20);
    border:1px solid rgba(255,255,255,.12);
    border-radius: 16px;
    padding:12px 14px;
    font-size:18px;
    line-height:2.0;
    min-height:140px;
  }
</style>
</head>
<body>
<div class="bg" aria-hidden="true"></div>

<div class="wrap">
  <header>
    <div>
      <h1>Tanka Lab — Beauty Research</h1>
      <div class="sub">
        Click Builder. Same 15 tiles per round (7 theme + 4 neutral + 2 particles + 2 actions, no duplicates).
        Adding particles/actions makes poems actually “move”.
      </div>
    </div>
    <div class="pill" id="status">Ready</div>
  </header>

  <div class="grid">
    <!-- Left: builder -->
    <section class="card">
      <div class="row">
        <span class="label">Fixed word (surface)</span>
        <input id="fixedSurface" placeholder="e.g., 葡萄 / ぶどう / 車 / さくら" />

        <span class="label">Reading (hiragana)</span>
        <input id="fixedReading" class="small" placeholder="required for kanji: ぶどう / くるま" />

        <span class="label" id="autoHint" style="margin-left:auto">Kana OK</span>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="newRoundBtn" class="btn primary">New Round</button>
        <button id="resetBtn" class="btn ghost">Reset Layout</button>
        <button id="copyBtn" class="btn secondary">Copy</button>
      </div>

      <div class="hint" style="margin-top:10px">
        • Click a <strong>line</strong> to select it, then click a <strong>tile</strong> to place.<br/>
        • Click a placed token to remove (returns to pool).<br/>
        • Fixed word must be used at least once (place the Fixed tile).
      </div>

      <div class="warning" id="warningBox"></div>

      <div class="sep"></div>
      <div class="label">Tile pool (15 + Fixed)</div>
      <div class="pool" id="pool"></div>

      <div class="sep"></div>
      <div class="label">Builder</div>
      <div class="lines" id="lines"></div>

      <div class="sep"></div>
      <div class="label">Full tanka</div>
      <div class="fullBox" id="full"></div>
      <div class="mono" id="meter"></div>
    </section>

    <!-- Right: research panel -->
    <aside class="card">
      <div class="label">Research panel</div>
      <div class="hint" style="margin-top:8px">
        Background reacts to structure (kanji density, abstract/concrete balance, vowel color, wobble).
      </div>

      <div class="sep"></div>

      <div class="panelGrid">
        <div class="kpiCard">
          <div class="kpiTitle">Kanji density</div>
          <div style="display:flex;align-items:center;gap:12px">
            <svg width="64" height="64" viewBox="0 0 64 64">
              <circle cx="32" cy="32" r="24" fill="none" stroke="rgba(255,255,255,.10)" stroke-width="8"/>
              <circle id="ringArc" cx="32" cy="32" r="24" fill="none" stroke="rgba(10,132,255,.85)" stroke-linecap="round" stroke-width="8"
                      stroke-dasharray="150.8" stroke-dashoffset="150.8" transform="rotate(-90 32 32)"/>
            </svg>
            <div>
              <div class="kpiBig" id="kanjiPct">0%</div>
              <div class="mono" id="kanjiNote">0 / 0</div>
            </div>
          </div>
        </div>

        <div class="kpiCard">
          <div class="kpiTitle">Abstract vs concrete (tokens)</div>
          <div class="bar"><div id="absBar"></div></div>
          <div class="mono" style="margin-top:8px" id="absNote">abstract 0 • concrete 0</div>
        </div>

        <div class="kpiCard">
          <div class="kpiTitle">Vowels (a i u e o)</div>
          <div class="dots">
            <span class="dotLbl">a</span><span class="dot" id="va"></span>
            <span class="dotLbl">i</span><span class="dot" id="vi"></span>
            <span class="dotLbl">u</span><span class="dot" id="vu"></span>
            <span class="dotLbl">e</span><span class="dot" id="ve"></span>
            <span class="dotLbl">o</span><span class="dot" id="vo"></span>
          </div>
          <div class="mono" style="margin-top:8px" id="vowelNote">a0 i0 u0 e0 o0</div>
        </div>

        <div class="kpiCard">
          <div class="kpiTitle">Balance polygon</div>
          <svg width="160" height="120" viewBox="0 0 160 120">
            <polygon points="80,12 138,42 116,102 44,102 22,42"
                     fill="rgba(255,255,255,.03)" stroke="rgba(255,255,255,.10)"/>
            <polygon id="radarPoly" points="80,40 110,55 100,86 60,86 50,55"
                     fill="rgba(191,90,242,.18)" stroke="rgba(191,90,242,.70)" stroke-width="2"/>
          </svg>
          <div class="mono" id="radarNote">mora / kanji / concrete / vowel-even / softness</div>
        </div>
      </div>

      <div class="sep"></div>
      <div class="hint">
        Deck ratio this version: <strong>7 theme nouns</strong> + <strong>4 neutral nouns</strong> + <strong>2 particles</strong> + <strong>2 actions</strong>.
      </div>
    </aside>
  </div>
</div>

<script>
/* ===================== Basics ===================== */
const statusEl = document.getElementById("status");
const warnEl = document.getElementById("warningBox");
const fixedSurfaceEl = document.getElementById("fixedSurface");
const fixedReadingEl = document.getElementById("fixedReading");
const autoHintEl = document.getElementById("autoHint");
const poolEl = document.getElementById("pool");
const linesEl = document.getElementById("lines");
const fullEl = document.getElementById("full");
const meterEl = document.getElementById("meter");

const ringArc = document.getElementById("ringArc");
const kanjiPct = document.getElementById("kanjiPct");
const kanjiNote = document.getElementById("kanjiNote");
const absBar = document.getElementById("absBar");
const absNote = document.getElementById("absNote");
const va = document.getElementById("va");
const vi = document.getElementById("vi");
const vu = document.getElementById("vu");
const ve = document.getElementById("ve");
const vo = document.getElementById("vo");
const vowelNote = document.getElementById("vowelNote");
const radarPoly = document.getElementById("radarPoly");

function setStatus(t){ statusEl.textContent = t; }
function showWarn(msg){ warnEl.style.display="block"; warnEl.textContent = msg; }
function clearWarn(){ warnEl.style.display="none"; warnEl.textContent=""; }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

/* ===================== Mora utils ===================== */
const SMALL = new Set("ゃゅょぁぃぅぇぉゎャュョァィゥェォヮ".split(""));
function toHira(str){
  return (str||"").replace(/[\u30a1-\u30f6]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0x60));
}
function isKanaOnly(s){
  const h = toHira((s||"").trim());
  return !!h && /^[ぁ-ゖー]+$/.test(h);
}
function countMora(reading){
  const s = toHira((reading||"").trim());
  if(!s) return 0;
  let n = 0;
  for(const ch of s){
    if(ch === "ー"){ n++; continue; }
    if(SMALL.has(ch)) continue;
    if(ch.match(/[ぁ-ゖ]/)) n++;
  }
  return n;
}

/* ===================== Vowel + softness ===================== */
const VOWELS = ["a","i","u","e","o"];
function kanaVowel(ch){
  if(SMALL.has(ch) || ch === "ー") return null;
  const a = "あかさたなはまやらわがざだばぱぁゃ";
  const i = "いきしちにひみりぎじぢびぴぃ";
  const u = "うくすつぬふむゆるぐずづぶぷぅゅ";
  const e = "えけせてねへめれげぜでべぺぇ";
  const o = "おこそとのほもよろをごぞどぼぽぉょを";
  if(a.includes(ch)) return "a";
  if(i.includes(ch)) return "i";
  if(u.includes(ch)) return "u";
  if(e.includes(ch)) return "e";
  if(o.includes(ch)) return "o";
  return null;
}
function readingVowels(reading){
  const s = toHira((reading||"").trim());
  const out = [];
  for(const ch of s){
    const v = kanaVowel(ch);
    if(v) out.push(v);
  }
  return out;
}
function readingSoftness(reading){
  // returns 0..1 where higher = softer
  const s = toHira((reading||"").trim());
  let score = 0, cnt = 0;
  for(const ch of s){
    if(SMALL.has(ch) || ch==="ー") continue;
    if(!ch.match(/[ぁ-ゖ]/)) continue;
    cnt++;
    const hard = "かきくけこさしすせそたちつてとぱぴぷぺぽがぎぐげござじずぜぞだぢづでどばびぶべぼ";
    const soft = "まみむめもなにぬねのらりるれろやゆよわをはひふへほ";
    if(hard.includes(ch)) score += 0.15;
    else if(soft.includes(ch)) score += 0.85;
    else score += 0.55;
  }
  return cnt ? (score/cnt) : 0.55;
}

/* ===================== RNG ===================== */
function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=(h<<13)|(h>>>19);}return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return (h^=(h>>>16))>>>0;};}
function sfc32(a,b,c,d){return function(){a>>>=0;b>>>=0;c>>>=0;d>>>=0;let t=(a+b)|0;a=b^(b>>>9);b=(c+(c<<3))|0;c=(c<<21)|(c>>>11);d=(d+1)|0;t=(t+d)|0;c=(c+t)|0;return (t>>>0)/4294967296;};}
function makeRng(seed){const s=xmur3(seed);return sfc32(s(),s(),s(),s());}
function randi(rng,min,max){return Math.floor(rng()*(max-min+1))+min;}
function pick(rng, arr){return arr[randi(rng,0,arr.length-1)];}

/* ===================== Vocab ===================== */
function T(surface, reading, kind, isAbstract){
  const r = toHira(reading);
  const vowels = readingVowels(r);
  return {
    id: (crypto?.randomUUID?.() || Math.random().toString(16).slice(2)),
    surface,
    reading: r,
    kind,               // theme | neutral | particle | action | fixed
    isAbstract: !!isAbstract,
    mora: countMora(r),
    vowels,
    softness: readingSoftness(r),
  };
}

/* Theme (mostly nouns, Memory × Water) */
const THEME = [
  T("水面","みなも","theme",false), T("湖面","こめん","theme",false), T("波紋","はもん","theme",false),
  T("水滴","すいてき","theme",false), T("霧","きり","theme",false), T("潮","しお","theme",false),
  T("潮風","しおかぜ","theme",false), T("井戸","いど","theme",false), T("水路","すいろ","theme",false),
  T("薄氷","うすごおり","theme",false), T("水音","みずおと","theme",false), T("反射","はんしゃ","theme",false),
  T("透明","とうめい","theme",true), T("揺らぎ","ゆらぎ","theme",true),
  T("記憶","きおく","theme",true), T("残像","ざんぞう","theme",true), T("断片","だんぺん","theme",true),
  T("余白","よはく","theme",true), T("沈黙","ちんもく","theme",true), T("未明","みめい","theme",true),
];

/* Neutral nouns */
const NEUTRAL = [
  T("朝","あさ","neutral",false), T("夜","よる","neutral",false), T("空","そら","neutral",false),
  T("影","かげ","neutral",false), T("窓","まど","neutral",false), T("部屋","へや","neutral",false),
  T("道","みち","neutral",false), T("風","かぜ","neutral",false), T("雨","あめ","neutral",false),
  T("光","ひかり","neutral",false), T("手","て","neutral",false), T("声","こえ","neutral",false),
  T("あなた","あなた","neutral",true), T("わたし","わたし","neutral",true), T("今日","きょう","neutral",true),
];

/* Particles (the glue) */
const PARTICLES = [
  T("の","の","particle",false),
  T("に","に","particle",false),
  T("へ","へ","particle",false),
  T("で","で","particle",false),
  T("と","と","particle",false),
  T("を","を","particle",false),
  T("や","や","particle",false),
  T("から","から","particle",false),
  T("まで","まで","particle",false),
  T("だけ","だけ","particle",false),
];

/* Actions (verbs + texture words) */
const ACTIONS = [
  // verbs (movement)
  T("滲む","にじむ","action",false),
  T("揺れる","ゆれる","action",false),
  T("沈む","しずむ","action",false),
  T("浮かぶ","うかぶ","action",false),
  T("溶ける","とける","action",false),
  T("凍る","こおる","action",false),
  T("残る","のこる","action",false),
  T("消える","きえる","action",false),
  T("満ちる","みちる","action",false),
  // adverb/adjective-ish texture (still tiles, still mora)
  T("うすく","うすく","action",false),
  T("静かに","しずかに","action",true),
  T("ゆっくり","ゆっくり","action",true),
  T("ふと","ふと","action",true),
];

/* ===================== State ===================== */
const TARGET = [5,7,5,7,7];
const state = {
  seed: "",
  roundTiles: [],      // 15 tiles (7 theme + 4 neutral + 2 particle + 2 action)
  used: new Set(),     // tile ids used in lines
  lines: [[],[],[],[],[]],
  activeLine: 0,
  fixedToken: null,
};

function getFixedToken(){
  const surface = (fixedSurfaceEl.value||"").trim();
  const readingInput = (fixedReadingEl.value||"").trim();

  if(!surface) throw new Error("Please enter a fixed word.");

  if(isKanaOnly(surface)){
    const r = toHira(surface);
    if(countMora(r) <= 0) throw new Error("Could not read fixed word. Use hiragana.");
    return T(surface, r, "fixed", true);
  }

  if(!readingInput) throw new Error("Kanji detected. Please fill Reading in hiragana (e.g., 車 → くるま).");
  const r = toHira(readingInput);
  if(!isKanaOnly(r) || countMora(r) <= 0) throw new Error("Reading must be kana (recommended: hiragana).");
  return T(surface, r, "fixed", true);
}

function refreshHint(){
  const s = (fixedSurfaceEl.value||"").trim();
  if(!s){ autoHintEl.textContent = "Kana OK"; return; }
  autoHintEl.textContent = isKanaOnly(s) ? "Kana OK" : "Kanji detected → reading required";
}
fixedSurfaceEl.addEventListener("input", refreshHint);
refreshHint();

/* ===================== Round generation ===================== */
function uniqueSample(rng, arr, n){
  const pool = arr.slice();
  const out = [];
  while(out.length < n && pool.length){
    const idx = randi(rng, 0, pool.length-1);
    out.push(pool.splice(idx,1)[0]);
  }
  return out;
}

function newRound(){
  clearWarn();
  const fixed = getFixedToken();
  state.fixedToken = fixed;
  state.used = new Set();
  state.lines = [[],[],[],[],[]];
  state.activeLine = 0;

  state.seed = "round|" + fixed.reading + "|" + Date.now().toString(36) + "|" + Math.random().toString(36).slice(2,8);
  const rng = makeRng(state.seed);

  const theme7 = uniqueSample(rng, THEME, 7);
  const neutral4 = uniqueSample(rng, NEUTRAL, 4);
  const particle2 = uniqueSample(rng, PARTICLES, 2);
  const action2 = uniqueSample(rng, ACTIONS, 2);

  // ensure no duplicate surface in a round
  const seen = new Set();
  const tiles = [];
  for(const t of [...theme7, ...neutral4, ...particle2, ...action2]){
    if(seen.has(t.surface)) continue;
    seen.add(t.surface);
    tiles.push(t);
  }
  // top-up (very rare)
  const pools = [
    {arr: THEME, want:7, kind:"theme"},
    {arr: NEUTRAL, want:4, kind:"neutral"},
    {arr: PARTICLES, want:2, kind:"particle"},
    {arr: ACTIONS, want:2, kind:"action"},
  ];
  function countKind(kind){ return tiles.filter(x=>x.kind===kind).length; }
  while(tiles.length < 15){
    for(const p of pools){
      if(tiles.length >= 15) break;
      if(countKind(p.kind) >= p.want) continue;
      const cand = pick(rng, p.arr);
      if(seen.has(cand.surface)) continue;
      seen.add(cand.surface);
      tiles.push(cand);
    }
  }

  state.roundTiles = tiles;
  setStatus("New round ✓");
  renderAll();
}

/* ===================== Builder logic ===================== */
function allTilesWithFixed(){
  const fixed = state.fixedToken;
  return fixed ? [fixed, ...state.roundTiles] : [...state.roundTiles];
}
function findTileById(id){
  for(const t of allTilesWithFixed()){
    if(t.id === id) return t;
  }
  return null;
}
function lineMora(i){
  return state.lines[i].reduce((sum, id)=> sum + (findTileById(id)?.mora || 0), 0);
}
function canPlace(lineIdx, tile){
  if(!tile) return false;
  if(state.used.has(tile.id)) return false;
  const m = lineMora(lineIdx);
  return (m + tile.mora) <= TARGET[lineIdx];
}
function placeTile(lineIdx, tile){
  if(!tile) return;
  if(!canPlace(lineIdx, tile)){
    setStatus("Doesn't fit");
    return;
  }
  state.lines[lineIdx].push(tile.id);
  state.used.add(tile.id);
  setStatus(`Placed on line ${lineIdx+1}`);
  renderAll();
}
function removeTile(tileId){
  for(let i=0;i<5;i++){
    const idx = state.lines[i].indexOf(tileId);
    if(idx !== -1){
      state.lines[i].splice(idx,1);
      state.used.delete(tileId);
      setStatus("Removed");
      renderAll();
      return;
    }
  }
}
function clearLine(i){
  for(const id of state.lines[i]) state.used.delete(id);
  state.lines[i] = [];
  setStatus(`Cleared line ${i+1}`);
  renderAll();
}
function resetLayout(){
  clearWarn();
  state.used = new Set();
  state.lines = [[],[],[],[],[]];
  state.activeLine = 0;
  setStatus("Reset ✓");
  renderAll();
}
function validateFixedUsed(){
  const f = state.fixedToken;
  return !!(f && state.used.has(f.id));
}

/* ===================== Rendering ===================== */
function renderPool(){
  const tiles = allTilesWithFixed();
  poolEl.innerHTML = "";
  for(const t of tiles){
    const div = document.createElement("div");
    div.className = "tile" + (state.used.has(t.id) ? " used" : "");
    const tagTxt = (t.kind==="fixed") ? "fixed" : t.kind;
    const tagCls =
      (t.kind==="theme") ? "tag theme" :
      (t.kind==="neutral") ? "tag neutral" :
      (t.kind==="particle") ? "tag particle" :
      (t.kind==="action") ? "tag action" : "tag";

    div.innerHTML = `
      <div class="tileTop">
        <span class="${tagCls}">${tagTxt}</span>
        <span class="mora">${t.mora}</span>
      </div>
      <div class="word">${t.surface}</div>
      <div class="mora">${t.reading}</div>
    `;
    div.addEventListener("click", ()=>{
      if(state.used.has(t.id)) return;
      placeTile(state.activeLine, t);
    });
    poolEl.appendChild(div);
  }
}

function renderLines(){
  linesEl.innerHTML = "";
  for(let i=0;i<5;i++){
    const card = document.createElement("div");
    card.className = "lineCard" + (i===state.activeLine ? " active" : "");
    card.dataset.line = i;

    const m = lineMora(i);
    const ok = (m === TARGET[i]);
    const badge = ok ? `<span class="badge good">${m}/${TARGET[i]} ✓</span>`
                     : `<span class="badge ${m>TARGET[i]?'bad':''}">${m}/${TARGET[i]}</span>`;

    const tokens = state.lines[i].map(id=>{
      const t = findTileById(id);
      return `<span class="token" data-token="${id}">${t?.surface || "?"}<small>${t?.mora ?? ""}</small></span>`;
    }).join("");

    card.innerHTML = `
      <div class="lineHead">
        <div class="label">Line ${i+1} • target ${TARGET[i]}</div>
        ${badge}
      </div>
      <div class="tokens">${tokens || `<span class="label">Click tiles to add…</span>`}</div>
      <div class="lineFoot">
        <button class="mini btn ghost" data-act="select">Select</button>
        <button class="mini btn ghost" data-act="clear">Clear</button>
      </div>
    `;

    card.querySelector(`[data-act="select"]`).addEventListener("click", ()=>{
      state.activeLine = i;
      setStatus(`Selected line ${i+1}`);
      renderAll();
    });
    card.querySelector(`[data-act="clear"]`).addEventListener("click", ()=> clearLine(i));

    card.addEventListener("click", (e)=>{
      const tok = e.target.closest(".token");
      if(tok){
        const id = tok.dataset.token;
        removeTile(id);
      }
    });

    linesEl.appendChild(card);
  }
}

function renderFull(){
  const linesTxt = state.lines.map(arr => arr.map(id=> findTileById(id)?.surface || "").join(""));
  const linesRead = state.lines.map(arr => arr.map(id=> findTileById(id)?.reading || "").join(""));
  fullEl.textContent = linesTxt.join("\n");
  meterEl.textContent = `meter: ${linesRead.map(r=>countMora(r)).join(" / ")}  (target: 5 / 7 / 5 / 7 / 7)`;
  return {linesTxt, linesRead};
}

/* ===================== Metrics + visuals ===================== */
function countKanji(str){
  const m = (str||"").match(/[\u4E00-\u9FFF]/g);
  return m ? m.length : 0;
}
function totalChars(str){
  return (str||"").replace(/\s/g,"").length;
}
function computeMetrics(linesTxt, linesRead){
  const joinedTxt = linesTxt.join("");
  const k = countKanji(joinedTxt);
  const tot = totalChars(joinedTxt);
  const kanjiRatio = tot ? (k / tot) : 0;

  let abs = 0, conc = 0, tokenCount = 0;
  let softnessSum = 0;

  const vowelCounts = {a:0,i:0,u:0,e:0,o:0};
  for(const arr of state.lines){
    for(const id of arr){
      const t = findTileById(id);
      if(!t) continue;
      tokenCount++;
      if(t.isAbstract) abs++; else conc++;
      softnessSum += (t.softness ?? 0.55);
      for(const v of (t.vowels||[])) vowelCounts[v] = (vowelCounts[v]||0)+1;
    }
  }

  const softAvg = tokenCount ? (softnessSum / tokenCount) : 0.55;

  const vTotal = VOWELS.reduce((s,v)=> s + vowelCounts[v], 0) || 1;
  const p = VOWELS.map(v=> vowelCounts[v]/vTotal);
  const ideal = 1/5;
  const dev = p.reduce((s,x)=> s + Math.abs(x-ideal), 0);
  const vEven = clamp01(1 - dev*0.9);

  const lineM = linesRead.map(r=> countMora(r));
  const mean = lineM.reduce((s,x)=>s+x,0)/5;
  const varr = lineM.reduce((s,x)=> s + (x-mean)*(x-mean), 0)/5;
  const moraBalance = clamp01(1 - (varr/6));

  const concreteRatio = tokenCount ? conc/tokenCount : 0;
  const abstractRatio = tokenCount ? abs/tokenCount : 0;

  return { kanjiRatio, k, tot, abs, conc, tokenCount, vowelCounts, vEven, softAvg, moraBalance, abstractRatio, concreteRatio };
}

function setRing(pct){
  const C = 2*Math.PI*24;
  const off = C * (1 - pct);
  ringArc.setAttribute("stroke-dasharray", String(C));
  ringArc.setAttribute("stroke-dashoffset", String(off));
}
function setRadar(vals){
  const cx=80, cy=60, R=44;
  const angles = [-90, -18, 54, 126, 198].map(a=> a*Math.PI/180);
  const pts = vals.map((v, i)=>{
    const rr = R * clamp01(v);
    const x = cx + rr * Math.cos(angles[i]);
    const y = cy + rr * Math.sin(angles[i]);
    return `${x.toFixed(1)},${y.toFixed(1)}`;
  }).join(" ");
  radarPoly.setAttribute("points", pts);
}

function applyBackground(m){
  const hueMap = {a:28,i:210,u:235,e:190,o:275};
  const v = m.vowelCounts;
  const total = VOWELS.reduce((s,k)=>s+(v[k]||0),0) || 1;

  let hue = 220;
  for(const k of VOWELS){
    const w = (v[k]||0)/total;
    hue += w * (hueMap[k]-220);
  }

  const sat = 0.9 + m.kanjiRatio * 0.9;
  const blur = 18 + m.abstractRatio * 22;
  const wobble = 1 - m.moraBalance;
  const angle = 120 + wobble * 80;

  const soft = m.softAvg;
  const hA = (hue + 18 + soft*10) % 360;
  const hB = (hue + 260 - soft*16 + 360) % 360;
  const hC = (hue + 90 + (1-soft)*14) % 360;
  const L = 16 + m.concreteRatio*6 - m.abstractRatio*3;

  document.documentElement.style.setProperty("--bgA", `hsl(${hA} 74% ${L}%)`);
  document.documentElement.style.setProperty("--bgB", `hsl(${hB} 70% ${Math.max(12,L-2)}%)`);
  document.documentElement.style.setProperty("--bgC", `hsl(${hC} 76% ${Math.min(22,L+2)}%)`);
  document.documentElement.style.setProperty("--sat", sat.toFixed(2));
  document.documentElement.style.setProperty("--blur", `${blur.toFixed(1)}px`);
  document.documentElement.style.setProperty("--angle", `${angle.toFixed(0)}deg`);
}

function renderPanel(m){
  setRing(m.kanjiRatio);
  kanjiPct.textContent = `${Math.round(m.kanjiRatio*100)}%`;
  kanjiNote.textContent = `${m.k} / ${m.tot || 0}`;

  const absPct = m.tokenCount ? (m.abs / m.tokenCount) : 0;
  absBar.style.width = `${Math.round(absPct*100)}%`;
  absNote.textContent = `abstract ${m.abs} • concrete ${m.conc}`;

  const total = VOWELS.reduce((s,k)=>s+(m.vowelCounts[k]||0),0) || 1;
  const dom = Math.max(...VOWELS.map(k=> (m.vowelCounts[k]||0)/total));
  const th = Math.max(0.18, dom*0.75);
  function setDot(el, k){
    const p = (m.vowelCounts[k]||0)/total;
    el.classList.toggle("on", p >= th && m.tokenCount>0);
  }
  setDot(va,"a"); setDot(vi,"i"); setDot(vu,"u"); setDot(ve,"e"); setDot(vo,"o");
  vowelNote.textContent = `a${m.vowelCounts.a||0} i${m.vowelCounts.i||0} u${m.vowelCounts.u||0} e${m.vowelCounts.e||0} o${m.vowelCounts.o||0}`;

  const softness = m.softAvg; // 0..1
  setRadar([m.moraBalance, m.kanjiRatio, m.concreteRatio, m.vEven, softness]);
}

function renderAll(){
  renderPool();
  renderLines();
  const {linesTxt, linesRead} = renderFull();
  const m = computeMetrics(linesTxt, linesRead);
  applyBackground(m);
  renderPanel(m);

  const missingFixed = state.fixedToken && !validateFixedUsed();
  const anyOver = [0,1,2,3,4].some(i=> lineMora(i) > TARGET[i]);
  const anyIncomplete = [0,1,2,3,4].some(i=> lineMora(i) !== TARGET[i]);

  if(anyOver){
    showWarn("One or more lines exceed the mora target. Remove a token.");
  }else if(missingFixed){
    showWarn("Fixed word is not used yet. Place the Fixed tile at least once.");
  }else{
    clearWarn();
  }

  if(!anyOver && !missingFixed && !anyIncomplete){
    setStatus("Complete ✓");
  }
}

/* ===================== Buttons ===================== */
document.getElementById("newRoundBtn").addEventListener("click", ()=>{
  try{ newRound(); }
  catch(e){ setStatus("Error"); showWarn(e.message || String(e)); }
});
document.getElementById("resetBtn").addEventListener("click", ()=> resetLayout());
document.getElementById("copyBtn").addEventListener("click", async ()=>{
  const text = fullEl.textContent || "";
  if(!text.trim()){ setStatus("Nothing to copy"); return; }
  if(state.fixedToken && !validateFixedUsed()){
    setStatus("Fixed missing");
    showWarn("Please place the Fixed tile at least once before copying.");
    return;
  }
  try{
    await navigator.clipboard.writeText(text);
    setStatus("Copied ✓");
  }catch{
    setStatus("Copy failed");
    showWarn("Copy failed due to browser permission. You can select & copy manually.");
  }
});

/* ===================== Boot ===================== */
(function boot(){
  fixedSurfaceEl.value = "葡萄";
  fixedReadingEl.value = "ぶどう";
  refreshHint();
  try{
    newRound();
    setStatus("Ready ✓");
  }catch(e){
    setStatus("Ready");
    showWarn(e.message || String(e));
  }
})();
</script>
</body>
</html>